# fscan 项目并发机制分析文档

## 概述

fscan 是一款使用 Go 语言编写的内网综合扫描工具，其并发机制主要基于 Go 语言的 goroutine 和 channel 特性实现。该工具能够同时处理大量网络请求和扫描任务，从而实现高效的内网扫描。

## 并发机制核心组件

### 1. Channel 控制并发数

在 [Plugins/scanner.go](./Plugins/scanner.go) 文件中，定义了用于控制并发数的 channel：

```go
var ch = make(chan struct{}, common.Threads)
```

- 该 channel 是一个带缓冲的通道，缓冲区大小由 [common.Threads](./common/config.go#L72-L72) 控制
- 默认情况下，该值由命令行参数 `-threads` 指定，默认值通常为 600
- 通过向此 channel 发送数据来控制并发执行的 goroutine 数量

### 2. WaitGroup 等待任务完成

同样在 [Scan()](./Plugins/scanner.go#L17-L97) 函数中定义了 WaitGroup：

```go
var wg = sync.WaitGroup{}
```

- 用于等待所有扫描任务完成
- 在每个任务开始前调用 `wg.Add(1)`
- 在每个任务完成后调用 `wg.Done()`
- 主线程通过 `wg.Wait()` 等待所有任务结束

### 3. AddScan 函数实现任务调度

这是并发机制的核心实现：

```go
func AddScan(scantype string, info common.HostInfo, ch *chan struct{}, wg *sync.WaitGroup) {
	*ch <- struct{}{}              // 获取一个执行许可（阻塞直到有空闲槽位）
	wg.Add(1)                      // 增加等待计数
	go func() {
		Mutex.Lock()
		common.Num += 1             // 任务总数增加
		Mutex.Unlock()
		ScanFunc(&scantype, &info)  // 执行实际扫描
		Mutex.Lock()
		common.End += 1             // 完成任务数增加
		Mutex.Unlock()
		wg.Done()                   // 通知 WaitGroup 任务完成
		<-(*ch)                     // 释放执行许可
	}()
}
```

### 4. 信号量机制

通过 channel 实现了经典的信号量模式：

- 向 channel 发送数据 (`*ch <- struct{}{}`) 相当于获取信号量
- 从 channel 接收数据 (`<-(*ch)`) 相当于释放信号量
- channel 的缓冲区大小决定了最大并发数

## 并发机制的工作流程

1. **初始化阶段**:
   - 创建带缓冲的 channel，缓冲区大小为 [Threads](./common/config.go#L72-L72) 参数
   - 创建 WaitGroup 实例

2. **任务提交阶段**:
   - 对于每个扫描任务，调用 [AddScan](./Plugins/scanner.go#L101-L112) 函数
   - 尝试向 channel 发送数据，如果当前并发数已达上限，则阻塞等待

3. **执行阶段**:
   - 成功发送数据到 channel 后，启动一个新的 goroutine 执行扫描任务
   - 在 goroutine 中增加 WaitGroup 计数
   - 执行实际的扫描工作
   - 完成后减少 WaitGroup 计数并从 channel 接收回数据以释放信号量

4. **等待阶段**:
   - 主线程调用 `wg.Wait()` 等待所有任务完成

## 并发安全机制

### 1. 互斥锁保护共享资源

```go
var Mutex = &sync.Mutex{}
```

在 [AddScan](./Plugins/scanner.go#L101-L112) 函数中，使用互斥锁保护对共享变量的访问：

```go
Mutex.Lock()
common.Num += 1
Mutex.Unlock()

Mutex.Lock()
common.End += 1
Mutex.Unlock()
```

这些操作确保对 [common.Num](./common/log.go#L15-L15)（任务总数）和 [common.End](./common/log.go#L16-L16)（已完成任务数）的修改是原子性的。

### 2. 日志记录的并发处理

在 [common/log.go](./common/log.go) 中，也采用了类似的并发机制：

```go
var Results = make(chan *string)
var LogWG sync.WaitGroup

func LogSuccess(result string) {
	LogWG.Add(1)
	Results <- &result
}

func SaveLog() {
	for result := range Results {
		// 处理结果
		LogWG.Done()
	}
}
```

这确保了日志记录也是线程安全的，多个 goroutine 可以同时记录日志而不会发生冲突。

## 性能优化措施

### 1. 内存垃圾回收 (GC)

在 [Plugins/scanner.go](./Plugins/scanner.go) 中多次调用了 `common.GC()`：

```go
common.GC()  // 在不同阶段调用以释放内存
```

### 2. 合理的并发度设置

- 默认线程数设置为 600，这是一个经过实践验证的平衡值
- 用户可以通过 `-threads` 参数自定义并发数，适应不同的网络环境

## 总结

fscan 的并发机制通过 Go 语言的 goroutine 和 channel 特性实现了高效的任务调度和资源管理。其设计亮点包括：

1. 使用 channel 实现信号量模式，精确控制并发数量
2. 结合 WaitGroup 确保所有任务正确完成
3. 通过互斥锁保护共享资源的并发访问
4. 采用管道模式处理日志输出，确保线程安全
5. 通过定期 GC 优化内存使用

这种设计使得 fscan 能够高效地处理大量网络扫描任务，同时保持程序的稳定性和可靠性。