# 杂七杂八灵光

使用 goflags 包处理命令行参数
github.com/projectdiscovery/goflags
最终对比选型，决定使用 Cobra 框架来处理命令行参数。

# 并发控制
agent 端本身也需要队列或者并发控制，根据参考再决定使用哪种
分级解耦和线程池架构，主要在 `run` 命令上添加


# agent 有两个模式
- Cluster Mode：注册到Master，接受任务并执行
- CLI Mode：本身可作为扫描工具，直接在命令行执行扫描任务

端口扫描 功能有参数（例如：--services，可以指定对识别的端口进行详细服务识别），不指定默认只进行端口探测和基础的服务识别

端口扫描 + 服务扫描 = 端口服务扫描 PortServiceScanner ，放在同一个流水线内解决，不再割裂，这个PortServiceScanner是智能的，只要端口状态，他就只做 portScan，需要服务识别，那就紧接着做服务识别 serverScan 
- 这个基础上，已经删除单数的serverScan，合并到了 PortServiceScanner

## 跨平台编译 ($env:GOOS="linux";$env:GOARCH="amd64"; go build -o neoAgent_linux ./cmd/agent)
# 1. 设置环境变量 (临时生效)
 $env:GOOS="linux"
 $env:GOARCH="amd64"

# 2. 执行编译
 go build -o neoAgent_linux ./cmd/agent

# 3. (可选) 恢复环境变量，以免影响后续 Windows 编译
 $env:GOOS="windows"



# CLI 模式与 Server 模式的统一

// 核心都是使用 RunnerManager，只是输入来源不同
// CLI 模式
task := options.ToTask()  // 从命令行参数创建
results := runner.Execute(ctx, task)
reporter.PrintResults(results)

// Server 模式
task := converter.AgentTaskToModelTask(agentTask)  // 从 Master 任务创建
results := runner.Execute(ctx, task)
resultData := converter.ModelResultToContract(results)
masterClient.UploadResult(taskID, resultData)  // 上报给 Master


# 后期可完善 Pipeline（1 周）
  现阶段流水线扫描调用各个scanner的参数都是硬编码固定的，后续可以通过 YAML 配置文件进行配置

  目标：让 scan run 支持更多配置，实现更精细的流水线扫描

  // 支持 YAML 配置
  type PipelineConfig struct {
      Name    string
      Stages  []StageConfig
  }

  // configs/pipeline.yaml
  pipelines:
    full_scan:
      stages:
        - type: alive
          concurrency: 1000
        - type: port
          ports: top1000
          concurrency: 200
        - type: service
          concurrency: 50
        - type: os
          concurrency: 20

  ## 使用配置文件
  ./neoAgent scan run -t 192.168.1.0/24 -c full_scan.yaml



