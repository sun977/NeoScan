# neoAgent 核心代码目录结构说明

本文档详细说明了 `neoAgent` 核心代码 (`internal/core`) 和 CLI 入口代码 (`cmd/agent`) 的目录结构及其设计意图。

## 1. 核心业务逻辑 (`internal/core`)

`internal/core` 是 neoAgent 的心脏，包含了所有与业务逻辑、任务调度、扫描能力相关的代码。它遵循 **高内聚、低耦合** 的设计原则，各模块职责分明。

### 目录结构概览

```
internal/core/
├── model/           # 数据模型定义
├── options/         # 任务参数解析与校验
├── reporter/        # 结果上报与输出
├── runner/          # 任务调度与执行器
└── scanner/         # 具体扫描能力实现
```

### 1.1 `model/` (数据模型)
定义了系统中最基础的数据结构，是各模块间通信的通用语言。
- `task.go`: 定义了 `Task` (任务输入) 和 `TaskResult` (任务输出) 结构体。
- `result_types.go`: 定义了各具体扫描类型的 Result 结构 (如 `IpAliveResult`)，以及表格化输出接口。

### 1.2 `options/` (参数层)
负责将松散的 Map[string]interface{} 或 CLI Flags 转换为强类型的配置结构体。
- `types.go`: 定义通用的 Option 接口。
- `scan_*.go`: 各类扫描任务的具体参数定义 (如 `IpAliveScanOptions`, `PortScanOptions`)。
- `output.go`: 全局输出参数定义 (`--oc`, `--oj`)。

### 1.3 `reporter/` (输出层)
负责处理任务执行结果的展示和存储。
- `interface.go`: 定义 `Reporter` 接口和 `TabularData` 接口。
- `console.go`: `ConsoleReporter` 实现，负责将结果渲染为漂亮的 CLI 表格。

### 1.4 `runner/` (调度层)
负责任务的生命周期管理、并发控制和调度。
- `interface.go`: 定义 `Runner` 接口。
- `manager.go`: `RunnerManager` 实现，负责注册 Runner、分发任务、汇总结果。

### 1.5 `scanner/` (能力层)
包含所有具体的安全扫描逻辑实现。这是 "Dirty Work" 发生的地方。
- `interface.go`: 定义 `Scanner` 接口。
- `alive/`: **IP 存活扫描 (Host Discovery)**
  - `alive.go`: `IpAliveScanner` 核心逻辑，包含自动/手动策略选择。
  - `prober.go`: 定义 `Prober` 接口 (探测器)。
  - `arp_*.go`: ARP 探测的具体实现 (Windows/Linux 平台差异化)。
  - `icmp.go`: ICMP Ping 探测实现。
  - `tcp_connect.go`: TCP 全连接探测实现。

---

## 2. CLI 入口 (`cmd/agent`)

`cmd/agent` 是程序的入口，负责处理命令行参数、初始化配置、组装 Core 组件并启动任务。它使用了 `Cobra` 库构建命令树。

### 目录结构概览

```
cmd/agent/
├── main.go          # 程序主入口 (main函数)
├── root.go          # 根命令定义 (neoAgent)
├── server.go        # server 子命令 (集群模式)
├── proxy/           # proxy 子命令 (代理模块)
│   └── root.go
└── scan/            # scan 子命令集 (扫描模块)
    ├── root.go      # scan 父命令
    ├── alive.go     # scan alive 子命令
    ├── port.go      # scan port 子命令
    ├── service.go   # scan service 子命令
    ├── os.go        # scan os 子命令
    ├── web.go       # scan web 子命令
    ├── vuln.go      # scan vuln 子命令
    ├── dir.go       # scan dir 子命令
    └── subdomain.go # scan subdomain 子命令
```

### 关键文件说明

- **`main.go`**: 极其精简，只负责调用 `Execute()`。
- **`root.go`**: 定义全局 Flag (如 `--config`)，初始化 Viper 配置。
- **`scan/root.go`**: 定义 `scan` 命令及其全局 Flag (如 `--oc`, `--oj`)，并注册所有子扫描命令。
- **`scan/alive.go`**:
  - 负责绑定 `scan alive` 的 Flags。
  - 负责将 CLI 参数转换为 `IpAliveScanOptions`。
  - 负责组装 `RunnerManager` 和 `IpAliveScanner`。
  - 负责调用 `ConsoleReporter` 输出结果。

## 3. 设计哲学 (Linus Perspective)

1.  **分层架构 (Layered Architecture)**:
    - **CLI Layer** (`cmd/`) -> **Option Layer** (`core/options`) -> **Runner Layer** (`core/runner`) -> **Scanner Layer** (`core/scanner`)。
    - 每一层只知道下一层的存在，严禁跨层调用。

2.  **原子化设计 (Atomicity)**:
    - 扫描能力被拆解为最小原子单元 (Scanner)。例如 `alive` 负责存活，`port` 负责端口，互不干扰。
    - 这种设计便于测试、维护和组合。

3.  **平台无关性与适配 (Platform Independence)**:
    - 平台差异代码 (如 ARP 探测) 被封装在 `scanner/alive/arp_*.go` 中，对外暴露统一接口。
    - 上层逻辑无需关心底层是 Windows 还是 Linux。

4.  **强类型参数 (Strong Typing)**:
    - 所有的 `map[string]interface{}` 最终都会被转换为强类型的 `Options` 结构体。
    - 拒绝在业务逻辑中传递弱类型的 Map，那是 Bug 的温床。
