# NeoAgent 第三方扫描工具集成策略 v1.0

## 1. 核心理念

**"Battery Included, but Plug-in Compatible"**

Agent 应追求极致的 **单文件部署 (Single Binary)** 体验。
- **原则 1**: 能用 Go 原生库实现的，绝不调用外部进程。
- **原则 2**: 核心高频能力（端口、指纹、爆破）必须内化，拒绝依赖地狱。
- **原则 3**: 仅在生态壁垒极高（如 Nuclei POC 库）或技术栈不可替代（如 Chromium 渲染）时，才引入外部工具。

---

## 2. 工具集成清单与决策

### 2.1 🚫 拒绝调用 (Native Replacement)
此类工具功能简单或 Go 生态有完美替代品，调用外部进程属于架构设计失误。

| 原工具 | 替代方案 | 理由 | 决策 |
| :--- | :--- | :--- | :--- |
| **Masscan** | Go `net/syscall` (Raw Socket) | Masscan 依赖 libpcap/winpcap，部署极其麻烦。Go 的高并发扫描性能已足够。 | **原生实现** |
| **Fscan** | Logic Merge | Fscan 本身即为 Go 项目。应参考其逻辑或引用其代码，而非调用二进制。 | **逻辑内化** |
| **HTTPx** | `projectdiscovery/httpx` (Lib) | 官方提供 Go 库。作为 Library 编译进 Agent，比调用 CLI 更快更稳。 | **库引用** |
| **Dirsearch** | Go Native HTTP Loop | 目录爆破仅为简单的 HTTP GET 循环。无需引入 Python 环境。 | **原生实现** |
| **Web爬虫** | `gocolly/colly` (Lib) | Go 拥有世界级的爬虫框架 Colly，性能远超 Python 脚本。 | **库引用** |

### 2.2 ⚠️ 谨慎调用 (Optional Wrapper)
此类工具功能强大但笨重，仅作为特定场景下的补充。

| 原工具 | 集成方式 | 理由 | 决策 |
| :--- | :--- | :--- | :--- |
| **Nmap** | Optional Plugin | Nmap 的 OS 指纹库和 NSE 脚本无可替代。但在 90% 的常规扫描中不需要它。 | **按需调用** |
| **Hydra** | Optional Plugin | 支持协议极多。常见协议 (SSH/MySQL) 用 Go 原生；冷门协议 (AFP/CVS) 调 Hydra。 | **按需调用** |

### 2.3 ✅ 必须集成 (Core Integration)
此类工具拥有难以复制的生态或技术壁垒。

| 原工具 | 集成方式 | 理由 | 决策 |
| :--- | :--- | :--- | :--- |
| **Nuclei** | Library Embed / Bin Wrapper | 核心资产是海量 YAML POC。应尽量作为 Go 库嵌入，或下载二进制管理。 | **深度集成** |
| **Chromium** | `chromedp` (Lib) | 现代 Web 扫描必须依赖 JS 渲染（截图、DOM XSS）。Go 无法自研浏览器内核。 | **Headless调用** |
| **Yara** | `go-yara` (CGO) | 恶意软件特征匹配的工业标准。使用 CGO 绑定调用 libyara。 | **CGO绑定** |

---

## 3. 实现路径建议

### 3.1 端口扫描 (Port Scan)
- **Default**: 使用 Go `net.Dial` (Connect Scan) 或 `syscall` (SYN Scan) 实现高并发扫描。
- **Fallback**: 仅在用户显式指定 `--use-nmap` 时尝试调用 Nmap。

### 3.2 漏洞扫描 (Vuln Scan)
- 优先尝试使用 `projectdiscovery/nuclei/v3/pkg` 作为库引入。
- 如果库引用导致二进制体积过大，则回退到自动下载 `nuclei` 二进制文件的模式。

### 3.3 Web 扫描
- **指纹/目录**: 使用 Go 原生 HTTP Client + 并发协程。
- **高级扫描**: 使用 `chromedp` 驱动本地安装的 Chrome/Chromium 进行截图和爬虫。
