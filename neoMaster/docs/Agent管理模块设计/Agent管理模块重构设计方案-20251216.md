# Agent 标签与能力体系重构设计方案

> **Author**: Sun977

> **Date**: 2025-12-16  

> **Status**: Draft / Proposal  

## 1. 现状与问题 (The Bad Taste)

当前 `Agent` 模块的设计在数据结构上存在严重的“品味问题”，主要体现在 `tags` 和 `capabilities` 两个字段的处理上。

### 1.1 当前设计
- **Tags**: 在 `agent` 表中使用 `json` 类型字段存储标签 ID 列表 (e.g., `["1", "5"]`)。
- **Capabilities**: 在 `agent` 表中使用 `json` 类型字段存储扫描类型 ID 列表 (e.g., `["2", "3"]`)，对应 `agent_scan_types` 表。

### 1.2 核心问题 (Critical Issues)

1.  **丧失数据完整性 (No Referential Integrity)**
    - JSON 数组中的 ID 只是纯文本，数据库无法通过外键约束（FK）来保证这些 ID 的有效性。
    - 如果在 `SysTag` 或 `ScanType` 表中删除了某条记录，`agent` 表中的数据就会变成“悬空指针”，导致**数据腐烂 (Data Rot)**。

2.  **反向查询噩梦 (The Reverse Lookup Nightmare)**
    - 无法高效回答“找出所有支持 PortScan 的在线 Agent”这类基础调度问题。
    - 必须使用低效的 `JSON_CONTAINS` 或字符串匹配，导致数据库索引失效，全表扫描不可避免。

3.  **系统不一致性 (Inconsistency)**
    - **资产 (Asset)** 模块正确使用了 `SysEntityTag` (Many-to-Many 关联表) 来管理标签。
    - **节点 (Agent)** 模块却使用 JSON 字段。
    - 这种“精神分裂”的设计增加了系统的认知负担和维护成本。

4.  **概念混淆**
    - `Capabilities` 本质上是 Agent 的一种属性（Attribute）或标签（Tag），却被特殊对待，开辟了独立的字段，导致无法复用通用的标签筛选、搜索和规则引擎能力。

---

## 2. 重构目标 (The Good Taste)

1.  **统一模型**：将 Agent 视为系统中的一种标准 **实体 (Entity)**，完全复用新设计的通用标签系统。
2.  **单一真理源 (Single Source of Truth)**：`agent_scan_types` 表定义能力，`sys_tags` 表作为其投影，确保定义与筛选分离但同步。
3.  **强一致性**：利用关系型数据库的关联表特性，保证数据的完整性和查询的高效性。
4.  **通用接口**：前端和调度器使用统一的标签查询接口（Tag Search API）来筛选 Agent，无需为 Capabilities 编写特殊逻辑。

---

## 3. 详细重构方案

### 3.1 数据库层变更 (Schema Changes)

#### A. Agent 表结构优化
- **保留** `agent` 表中的 `TaskSupport` 和 `Feature` 字段，作为 Agent 上报的原始数据快照。
  - `TaskSupport`: 存储 Agent 支持的任务类型标识符列表 (e.g. `["port_scan", "web_scan"]`)。
  - `Feature`: 存储 Agent 的特性功能列表 (e.g. `["shell", "file_upload"]`)。
- **目的**: 虽然标签系统 (`sys_entity_tags`) 是筛选和调度的核心，但保留原始字段有助于：
  1.  **快速诊断**: 管理员可以直接查看 Agent 上报的原始值，排查标签映射问题。
  2.  **数据备份**: 当标签系统规则变更或重建时，原始数据不会丢失。

#### B. 扩展 Agent Scan Types 表
在 `agent_scan_types` 表中建立与标签系统的**硬链接**。

```go
type ScanType struct {
    ID    uint64
    Name  string // e.g., "PortScan"
    // ... 其他执行参数 ...
    
    // 新增：关联的系统标签ID
    // 这建立了 "能力定义" -> "标签筛选" 的 O(1) 映射
    TagID uint64 `gorm:"uniqueIndex"` 
}
```

#### C. 复用 SysEntityTag 表
直接使用现有的 `sys_entity_tags` 表存储 Agent 的标签和能力。
- `EntityType`: 固定为 `"agent"`
- `EntityID`: Agent 的 UUID
- `TagID`: 对应普通标签或能力标签的 ID
- `Source`: 
    - `'manual'` (手动打标)
    - `'agent_report'` (Agent 心跳上报的能力)

### 3.2 标签树结构设计 (The Skeleton)

我们需要在系统初始化时预设标签树的**骨架**，但**叶子节点**（具体能力）应由代码动态维护。

我们将原来的 `Capabilities` 概念拆分为更精准的两个维度：

1.  **TaskSupport** (任务支持): 与 `ScanType` 一一对应，明确表示 Agent 支持执行的任务类型。
2.  **Feature** (特性功能): 表示 Agent 具备的非任务类核心能力（如 Shell 执行、文件操作、Root 权限等）。

**预设骨架 (SQL/Init)**:
```text
ROOT (ID: 1)
├── System (Category: 'system')
│   ├── TaskSupport (Category: 'system', Path: '/1/2/')  <-- 对应 ScanType (e.g. PortScan, WebScan)
│   └── Feature (Category: 'system', Path: '/1/3/')      <-- 对应通用能力 (e.g. ShellExec, FileUpload)
└── AgentGroup (Category: 'agent_group')                 <-- 分组根节点
    └── Default (Category: 'agent_group', Path: '/1/4/') <-- 默认分组 (新注册Agent默认归属)
```


### 3.3 镜像同步机制 (The Mirroring Mechanism)

为了解决“能力定义在 ScanType 表，筛选在 Tag 表”的问题，建立自动同步机制。

**启动引导逻辑 (Bootstrap Logic)**:
当 Master 启动时：
1.  **同步 TaskSupport**:
    - 读取 `agent_scan_types` 表的所有记录。
    - 检查 `/System/TaskSupport/` 路径下是否存在同名标签。
    - **不存在则自动创建**，并将生成的 `TagID` 回写到 `agent_scan_types.tag_id`。
2.  **同步 Feature (可选)**:
    - 如果有预定义的 Feature 列表（如枚举值），同样在 `/System/Feature/` 下自动创建。
3.  **锁定标签**:
    - 设置生成的标签 `IsSystem = true` (防止用户手动删除)。
4.  **初始化 AgentGroup**:
    - 确保 `/AgentGroup/Default` 存在。
    - 设置 `IsSystem = true`。

**运行时同步 (Runtime Sync - 严格模式)**:
- **强校验 (Strict Validation)**: 
  - 当 Agent 注册上报 `TaskSupport` 时，Master 会在数据库中查找对应的 Tag。
  - **Fail Fast**: 如果发现任何未知的 `TaskSupport`（即无法映射到现有 Tag），直接**拒绝注册**并返回错误。
  - **拒绝垃圾数据**: 绝不自动创建未知的 ScanType 或 Tag。这迫使管理员必须先在后台定义好能力，Agent 才能使用。
- **管理流**: 
  - 管理员在后台新增 `ScanType` -> 触发 Hook 同步创建 Tag。
  - Agent 启动 -> 上报能力 -> 校验通过 -> 注册成功。

### 3.4 运行时数据流 (Runtime Flow)

**场景：Agent 能力上报与同步**

**原则**: 
- **心跳纯粹性**: 心跳包 (Heartbeat) 只包含状态 (Alive/Dead) 和动态指标 (Metrics)，**绝不**包含静态能力数据。
- **注册即真理**: Agent 的能力 (Capabilities) 仅在 **注册 (Register)** 或 **显式更新 (Update)** 时上报。

**1. 注册时上报 (Register Time)**
   - Agent 启动时调用注册接口:
     `Register { Hostname: "node-1", TaskSupport: ["PortScan"], Features: ["ShellExec"] }`
   - Master 处理:
    - 验证 Agent 身份。
    - 解析 `TaskSupport` 和 `Features`。
    - **校验能力**: 检查上报的 `TaskSupport` 是否在系统中有对应的 ScanType/Tag 定义。
      - 如果无效：**中断流程，返回 Error**。
    - 校验通过后，调用 `tagService.SyncEntityTags(..., "agent_capability")` 将能力映射为系统标签。

**2. 运行时变更 (Runtime Update)**
   - 如果 Agent 在运行时加载了新插件 (e.g. 热加载了 "WebScan" 插件)。
   - Agent **主动调用** 更新接口 (非心跳接口):
     `UpdateConfig { AgentID: "xyz", TaskSupport: ["PortScan", "WebScan"] }`
   - Master 收到请求后，重新执行标签同步逻辑。

**3. 数据一致性保障**
   - **重启强制注册**: Agent 进程重启后，必须强制走一次注册流程，确保 Master 端的 Tag 是最新的。
   - **Master 重建感知**: 如果 Master 数据库丢失，Agent 心跳会返回 `404` 或 `Unregistered`，触发 Agent 重新发起注册流程。

---

## 4. 迁移策略 (Migration Strategy)

为了在不破坏现有数据的前提下完成重构，建议按以下步骤操作：

1.  **Pre-Flight**: 备份数据库。
2.  **Schema Upgrade**: 
    - 向 `agent_scan_types` 添加 `tag_id` 列。
    - 确保 `sys_tags` 中存在 `/System/Capability/` 骨架。
3.  **Data Migration (Script)**:
    - 遍历 `agent_scan_types`，为每个类型创建对应的 `SysTag` 并回填 `tag_id`。
    - **Group Migration**: 
        - 遍历 `agent_groups`，为每个组创建 `SysTag` (Category='agent_group')，记录 `OldGroupID` -> `NewTagID` 的映射。
        - 遍历 `agent_group_members`，利用映射关系，将成员关系插入 `sys_entity_tags`。
    - 遍历 `agent` 表：
        - 解析 `tags` JSON，插入 `sys_entity_tags` (Source='manual')。
        - 解析 `capabilities` JSON，映射到对应的 `TagID`，插入 `sys_entity_tags` (Source='agent_report')。
4.  **Code Switch**: 部署新代码（移除旧字段的读写，启用新的心跳处理逻辑）。
5.  **Cleanup**: 删除 `agent` 表中的旧字段。

---

## 5. 最终效果 (The Outcome)

通过此次重构，我们达成：
- **统一的搜索接口**：`SELECT * FROM agents WHERE tag_id IN (...)` 即可筛选任意属性或能力的 Agent。
- **干净的数据库**：没有非结构化的 JSON 字段，所有关系均由 FK 约束。
- **自动化维护**：新增扫描能力只需在 `agent_scan_types` 插入一条记录，标签系统自动感知，无需人工干预。

---

## 6. 关于 Agent 分组 (The Grouping Dilemma)

你提到了现有的 `AgentGroup` (分组) 功能。经过评估，我的结论是：**它应该被“枪毙”，并入标签体系。**

### 6.1 为什么分组是多余的？
在数学上，**分组 (Group)** 和 **标签 (Tag)** 是同构的：它们都定义了一个“集合”。
- 现在的设计：你有两套平行的系统来管理集合。
    1.  `agent_group_members` (Group A -> Agents)
    2.  `sys_entity_tags` (Tag B -> Agents)
- 这导致了**组合查询的复杂度爆炸**：
    - "找出 A 组中拥有 B 标签的 Agent" -> 需要跨两套表做 Join。
    - "找出 A 组和 C 组的交集" -> 需要写专门的分组逻辑。

### 6.2 更好的方案：Group as a Tag (Concept Unification)
**分组只是标签的一种“方言”。**

- 当你说“这个 Agent 属于爬虫组”时，在底层数据上，这和“这个 Agent 属于 Linux 系统”**没有任何区别**。
- 区别只在于**用户视角**：用户习惯把“组织架构”或“管理单元”称为“分组”。

**如何实现？**
我们只需要在标签系统中保留一个特殊的 **Category** 或 **根节点**，专门用来存放这些“具有分组语义”的标签。

1.  **数据迁移**：
    - 将所有 `AgentGroup` 记录迁移到 `SysTag` 表，设置 `Category = 'agent_group'`。
    - 建议使用层级路径：`/AgentGroup/Default`, `/AgentGroup/Dev/Backend`。
    - 将所有 `AgentGroupMember` 记录迁移到 `SysEntityTag` 表。

2.  **获得的“免费”能力**：
    - **层级分组**：原来的分组是扁平的，现在你可以轻松实现“部门/科室/小组”的树状管理。
    - **动态分组**：利用标签系统的 `SysMatchRule`，你可以创建一个“自动分组”，例如“所有 Linux 机器自动加入 Linux 组”。这是原有的静态分组无法做到的。
    - **统一视图**：前端资源树只需加载 `SysTag`，就能同时显示“分组”、“操作系统”、“扫描能力”等所有维度的分类。

### 6.3 结论
**Don't Multiply Entities Beyond Necessity.** (如无必要，勿增实体)
既然标签系统已经足够强大（支持手动、自动、层级），单独维护一套“分组”系统纯属浪费代码和脑力。建议在重构时一并废除 `AgentGroup` 相关表结构。

---

## 7. 典型应用场景 (Use Cases)

你问到的“根据功能自动分组”，正是这套系统的杀手锏。

### 场景：自动划分“爬虫组”与“漏扫组”

假设你部署了两类 Agent：
1.  **A类**: 配置为只运行 Web 爬虫 (ScanType: `web_crawler`)。
2.  **B类**: 配置为只运行漏洞扫描 (ScanType: `vuln_scan`)。

#### 流程演示：

1.  **Agent 上报 (自动)**
    - Agent A 启动，心跳上报: `SupportedTasks: ["web_crawler"]`
    - Agent B 启动，心跳上报: `SupportedTasks: ["vuln_scan"]`

2.  **系统映射 (自动)**
    - 系统检测到上报，自动给 Agent A 打上标签: `/System/TaskSupport/web_crawler`
    - 系统检测到上报，自动给 Agent B 打上标签: `/System/TaskSupport/vuln_scan`
    - *此时，你已经可以直接通过标签筛选这两类机器了。*

3.  **高级自动分组 (规则驱动)**
    如果你想更进一步，把它们自动归入业务组（例如 `/AgentGroup/SpiderSquad`），你可以配置一条 **SysMatchRule**：
    
    - **规则名称**: "Auto-Group Spiders"
    - **匹配条件**: `Tag IN ('/System/TaskSupport/web_crawler')`
    - **执行动作**: 添加标签 `/AgentGroup/SpiderSquad`
    
    **结果**: 任何新上线的爬虫 Agent，无需人工操作，会自动获得 `/AgentGroup/SpiderSquad` 标签，直接进入你的“爬虫小队”分组。

这就是 **Data-Driven Infrastructure**（数据驱动的基础设施）。你不再是手动拖拽机器进组，而是定义规则，让系统自我组织。

---

## 8. 实施状态 (2025-12-19)

### 8.1 已完成功能
- [x] **Schema 变更**: `ScanType` 表扩展了 `TagID` 字段。
- [x] **引导逻辑**: 启动时创建系统标签骨架 (ROOT, System, TaskSupport)。
- [x] **注册流程**:
    - 实现了 `TaskSupport` 的严格校验。
    - 注册成功后自动执行 `SyncEntityTags`。
    - 拒绝无效/未知的 `TaskSupport` 值。

### 8.2 待办 / 进行中
- [ ] **运行时更新一致性**:
    - `AddAgentTaskSupport` / `RemoveAgentTaskSupport` 仅更新数据库，缺失 `SyncEntityTags` 调用。
    - `UpdateAgentConfig` 接口目前仅为存根 (Stub)。
- [ ] **迁移脚本**: 编写 SQL/Go 脚本将现有数据迁移到新的标签结构。

### 8.3 下一步计划
1. 修复 `Add/RemoveAgentTaskSupport` 以确保标签一致性。
2. 实现 `UpdateAgentConfig` 以支持运行时能力更新。
3. 为现有 Agent 开发迁移策略。

