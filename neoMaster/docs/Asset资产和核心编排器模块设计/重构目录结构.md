# 目录结构设计 (Embedded Refactoring Edition)

本目录结构设计遵循 **"Never break userspace"** 原则。我们不推倒现有的 `internal/handler`, `internal/service`, `internal/repo` 结构，而是将新的设计理念（DDD、Pipeline、Tool Adapter）**嵌入**到现有结构中。

这是一种温和的重构策略，利用 `internal/pkg` 和 `internal/service` 的子包来承载新的核心逻辑，保持顶层结构的一致性。

## 目录树预览

```text
neoMaster/internal/
├── handler/                  # [保持不变] 接入层
│   ├── orchestrator/         # 调度相关 Handler
│   │   ├── workflow.go       # 调用 service/orchestrator
│   │   └── project.go
│   └── asset/                # 资产相关 Handler
│       └── asset.go          # 调用 service/asset
│
├── service/                  # [业务层] - 嵌入核心逻辑
│   ├── orchestrator/         # 编排服务域
│   │   ├── core/             # [新增] 核心编排逻辑 (The Brain)
│   │   │   ├── scheduler/    # 定时调度逻辑 (Cron解析)
│   │   │   ├── engine/       # 状态机引擎 (Stage流转核心)
│   │   │   └── dispatcher/   # 任务分发逻辑
│   │   ├── service.go        # [保持] 对外暴露的 Service 接口
│   │   └── workflow.go       # [保持] 现有业务逻辑
│   │
│   └── asset/                # 资产服务域
│       ├── pipeline/         # [新增] 数据处理流水线 (The Pipeline)
│       │   ├── resolver.go   # 目标解析 (Static/Dynamic)
│       │   ├── merger.go     # 资产合并逻辑 (ETL)
│       │   └── ingestion.go  # 结果摄入逻辑
│       └── service.go        # [保持] 对外暴露的 AssetService
│
├── pkg/                      # [通用库] - 嵌入基础设施
│   ├── tool_adapter/         # [新增] 工具适配层 (Infrastructure)
│   │   ├── factory/          # 命令生成工厂 (Command Builder)
│   │   ├── parser/           # 结果解析器接口 (Result Parser)
│   │   └── registry/         # 工具注册与版本管理
│   │
│   └── policy/               # [新增] 策略通用库
│       ├── whitelist/        # 白名单检查器
│       └── scope/            # 范围校验器
│
├── repo/                     # [持久层] - 配合新模型
│   ├── orchestrator/         # 扩展支持 ScanStage, ProjectConfig
│   └── asset/                # 扩展支持 AssetHost, StageResult
│
└── model/                    # [模型层] - 更新 Structs
    ├── orchestrator/         # Project, Workflow, ScanStage
    └── asset/                # AssetHost, StageResult, AssetNetworkScan
```

## 详细模块映射说明

### 1. Control Plane (大脑) -> `internal/service/orchestrator/core`
我们将原来的"上帝类"拆解为原子组件，放在 `core` 子包下：
*   **scheduler**: 负责 "When to run"。解析 Cron，生成触发事件。
*   **engine**: 负责 "What to run next"。这是**状态机**的栖息地。输入当前 Stage 状态，输出下一个 Stage。
*   **dispatcher**: 负责 "Where to run"。调用 `repo` 获取可用 Agent，分配任务。

### 2. Data Plane (流水线) -> `internal/service/asset/pipeline`
资产处理不再是简单的 CRUD，而是一条流水线：
*   **resolver.go**: 实现 `Resolve(target)`。如果是动态解析，它会去查询数据库；如果是静态，直接拆解 CIDR。
*   **merger.go**: 实现 `Merge(newResult)`。这是处理数据冲突（Conflict Resolution）的地方。

### 3. Infrastructure (基石) -> `internal/pkg/tool_adapter`
这是最独立的模块，放在 `pkg` 下意味着它**不依赖业务逻辑**，甚至可以被其他项目引用。
*   **factory**: `BuildCommand("nmap", config)` -> 返回 `nmap -sS ...` 字符串。
*   **parser**: `ParseOutput("nmap", xmlData)` -> 返回标准化的 `StageResult` 结构体。

### 4. Model Layer (模型) -> `internal/model`
**Strictly structs.** 保持贫血模型。
*   所有 GORM 的 tag (`gorm:"..."`) 和 JSON tag (`json:"..."`) 都在这里定义。
*   不要在这里写业务逻辑。

## 迁移策略 (Migration Strategy)

1.  **Phase 1: Foundation (基础设施)**
    *   创建 `internal/pkg/tool_adapter`。这是无依赖的，最安全。
    *   完善 `internal/model` 中的 Structs (基于 ER 图)。

2.  **Phase 2: The Core (核心逻辑)**
    *   在 `internal/service/orchestrator` 下创建 `core` 目录。
    *   编写 `engine` (状态机)，并为其编写单元测试。

3.  **Phase 3: The Pipeline (数据流)**
    *   在 `internal/service/asset` 下创建 `pipeline` 目录。
    *   迁移现有的资产保存逻辑到 `merger.go`。

4.  **Phase 4: Integration (集成)**
    *   修改现有的 `service.go`，让它调用 `core` 和 `pipeline` 中的组件，而不是自己写满 `if/else`。
