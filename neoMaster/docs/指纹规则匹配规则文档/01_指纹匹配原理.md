# 指纹匹配原理详解

本文档将深入讲解 NeoScan 指纹识别系统的工作原理，帮助您理解指纹规则是如何生效的。

## 系统架构概览

NeoScan 指纹识别系统由以下几个核心组件组成：

```
┌─────────────────────────────────────────────────────────────┐
│  指纹规则存储                                          │
│  - 数据库 (asset_finger 表)                              │
│  - JSON 文件 (rules/fingerprint/)                         │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  规则编译器 (compileRule)                               │
│  - 将简单字段转换为匹配条件                              │
│  - 解析 match 字段的 JSON 规则                          │
│  - 编译正则表达式                                        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  匹配引擎 (HTTPEngine)                                │
│  - 加载编译后的规则                                      │
│  - 遍历规则进行匹配                                      │
│  - 返回匹配结果                                          │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  匹配器 (matcher.Match)                                │
│  - 处理 AND/OR 逻辑                                     │
│  - 执行各种操作符                                        │
│  - 返回匹配结果                                          │
└─────────────────────────────────────────────────────────────┘
```

## 指纹匹配的完整流程

### 1. 规则加载阶段

当系统启动时，会执行以下操作：

```
1. 读取数据库中的指纹规则
   ↓
2. 读取 rules/fingerprint/ 目录下的 JSON 文件
   ↓
3. 对每条规则调用 compileRule() 进行编译
   ↓
4. 将编译后的规则加载到内存
   ↓
5. 准备好进行指纹识别
```

### 2. 指纹识别阶段

当扫描器扫描到一个目标时，会执行以下操作：

```
1. 访问目标网站，获取 HTTP 响应
   ↓
2. 提取 HTTP 响应的各个部分
   - 状态码 (status_code)
   - 响应头 (headers)
   - 响应体 (body)
   - 网页标题 (title)
   ↓
3. 调用 convertInputToMap() 转换数据
   - 将响应转换为统一的数据结构
   - 提取各个字段
   ↓
4. 遍历所有编译后的规则
   ↓
5. 对每条规则调用 matcher.Match() 进行匹配
   ↓
6. 如果匹配成功，生成识别结果
   ↓
7. 返回所有匹配的指纹
```

## 数据转换详解

系统会将 HTTP 响应转换为统一的数据结构，以便进行匹配。

### HTTP 响应示例

```http
HTTP/1.1 200 OK
Server: nginx/1.18.0
Content-Type: text/html; charset=UTF-8
X-Powered-By: PHP/7.4.3

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WordPress › Log In</title>
</head>
<body>
    <h1>WordPress Login</h1>
</body>
</html>
```

### 转换后的数据结构

```json
{
  "status_code": "200",
  "title": "WordPress › Log In",
  "body": "<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>WordPress › Log In</title>\n</head>\n<body>\n    <h1>WordPress Login</h1>\n</body>\n</html>",
  "headers": {
    "Server": "nginx/1.18.0",
    "Content-Type": "text/html; charset=UTF-8",
    "X-Powered-By": "PHP/7.4.3"
  },
  "all_headers": "Server: nginx/1.18.0\nContent-Type: text/html; charset=UTF-8\nX-Powered-By: PHP/7.4.3\n",
  "server": "nginx/1.18.0",
  "x_powered_by": "PHP/7.4.3",
  "all_response": "Server: nginx/1.18.0\nContent-Type: text/html; charset=UTF-8\nX-Powered-By: PHP/7.4.3\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>WordPress › Log In</title>\n</head>\n<body>\n    <h1>WordPress Login</h1>\n</body>\n</html>"
}
```

### 可用的匹配字段

| 字段名 | 说明 | 来源 |
|-------|------|------|
| `status_code` | HTTP 状态码 | 响应行 |
| `title` | 网页标题 | 从 HTML 的 `<title>` 标签提取 |
| `body` | 响应体内容 | HTTP 响应体 |
| `headers` | 所有响应头 | HTTP 响应头 |
| `all_headers` | 所有响应头的字符串形式 | 拼接所有响应头 |
| `server` | Server 响应头 | `headers["Server"]` |
| `x_powered_by` | X-Powered-By 响应头 | `headers["X-Powered-By"]` |
| `all_response` | 所有响应的字符串形式 | `all_headers + "\n" + body` |

## 规则编译详解

### 简单字段的编译

当您使用简单字段时，系统会自动将其转换为匹配条件。

#### 示例规则

```json
{
  "name": "WordPress",
  "status_code": "200",
  "title": "Log In"
}
```

#### 编译后的规则

```json
{
  "and": [
    {
      "field": "status_code",
      "operator": "equals",
      "value": "200"
    },
    {
      "field": "title",
      "operator": "contains",
      "value": "Log In",
      "ignore_case": true
    }
  ]
}
```

### match 字段的编译

当您使用 match 字段时，系统会根据内容进行不同的处理。

#### 格式1：正则表达式

```json
{
  "name": "WordPress",
  "match": "wp-.*"
}
```

编译后：

```json
{
  "field": "all_response",
  "operator": "regex",
  "value": "wp-.*"
}
```

#### 格式2：JSON 规则

```json
{
  "name": "WordPress",
  "match": {
    "and": [
      {"field": "status_code", "operator": "equals", "value": "200"},
      {"field": "title", "operator": "contains", "value": "Log In"}
    ]
  }
}
```
系统会判断 match 字段是否为 JSON 格式。如果是，直接使用该 JSON 规则；如果不是，将其视为正则表达式。

编译后：直接使用 JSON 规则，无需转换。

## 匹配逻辑详解

### AND 逻辑

当规则包含多个条件时，默认使用 AND 逻辑，所有条件都必须满足。

```json
{
  "and": [
    {"field": "status_code", "operator": "equals", "value": "200"},
    {"field": "title", "operator": "contains", "value": "Log In"}
  ]
}
```

匹配逻辑：
```
条件1 (status_code == "200") AND 条件2 (title contains "Log In")
```

只有当两个条件都满足时，规则才匹配成功。

### OR 逻辑

当规则使用 OR 逻辑时，只要有一个条件满足即可。

```json
{
  "or": [
    {"field": "status_code", "operator": "equals", "value": "200"},
    {"field": "status_code", "operator": "equals", "value": "301"}
  ]
}
```

匹配逻辑：
```
条件1 (status_code == "200") OR 条件2 (status_code == "301")
```

只要有一个条件满足，规则就匹配成功。

### 嵌套逻辑

系统支持 AND 和 OR 的嵌套组合。

```json
{
  "and": [
    {"field": "title", "operator": "contains", "value": "Login"},
    {"field": "server", "operator": "regex", "value": "nginx.*"},
    {
      "or": [
        {"field": "status_code", "operator": "equals", "value": "200"},
        {"field": "status_code", "operator": "equals", "value": "301"}
      ]
    }
  ]
}
```

匹配逻辑：
```
(title contains "Login") AND (server matches "nginx.*") AND (status_code == "200" OR status_code == "301")
```

## 操作符详解

### 字符串操作符

#### equals - 精确匹配

```json
{
  "field": "status_code",
  "operator": "equals",
  "value": "200"
}
```

匹配条件：`status_code == "200"`

#### contains - 包含匹配

```json
{
  "field": "title",
  "operator": "contains",
  "value": "Log In",
  "ignore_case": true
}
```

匹配条件：`title` 包含 `"Log In"`（忽略大小写）

#### starts_with - 以...开头

```json
{
  "field": "title",
  "operator": "starts_with",
  "value": "WordPress"
}
```

匹配条件：`title` 以 `"WordPress"` 开头

#### ends_with - 以...结尾

```json
{
  "field": "server",
  "operator": "ends_with",
  "value": ".0"
}
```

匹配条件：`server` 以 `".0"` 结尾

#### regex - 正则表达式匹配

```json
{
  "field": "all_response",
  "operator": "regex",
  "value": "wp-.*"
}
```

匹配条件：`all_response` 匹配正则表达式 `"wp-.*"`

### 数值操作符

#### greater_than - 大于

```json
{
  "field": "content_length",
  "operator": "greater_than",
  "value": 1000
}
```

匹配条件：`content_length > 1000`

#### less_than - 小于

```json
{
  "field": "content_length",
  "operator": "less_than",
  "value": 10000
}
```

匹配条件：`content_length < 10000`

### 存在性操作符

#### exists - 字段存在

```json
{
  "field": "server",
  "operator": "exists"
}
```

匹配条件：`server` 字段存在

#### is_null - 字段为空

```json
{
  "field": "x_powered_by",
  "operator": "is_null"
}
```

匹配条件：`x_powered_by` 字段为空

## 为什么只需要定义"识别什么"？

NeoScan 采用**声明式规则**设计，您只需要声明"要识别什么"，系统自动决定"怎么识别"。

### 传统命令式规则

```json
{
  "name": "WordPress",
  "rules": [
    {
      "step1": "extract_title_from_html",
      "step2": "check_if_contains",
      "value": "Log In",
      "case_sensitive": false
    }
  ]
}
```

您需要了解：
- 如何从 HTML 提取标题
- 如何进行字符串匹配
- 如何处理大小写

### NeoScan 声明式规则

```json
{
  "name": "WordPress",
  "title": "Log In"
}
```

您只需要知道：
- WordPress 的登录页标题是 "Log In"

系统自动处理：
- 提取 HTML 标题
- 进行字符串匹配
- 处理大小写

### 优势

1. **简化规则定义**：不需要了解底层实现细节
2. **降低学习成本**：只需要知道应用的特征
3. **提高可维护性**：匹配逻辑集中在引擎中
4. **性能优化**：引擎可以优化匹配算法

## 总结

1. **指纹匹配流程**：规则加载 → 数据转换 → 规则匹配 → 返回结果
2. **数据转换**：HTTP 响应转换为统一的数据结构
3. **规则编译**：简单字段自动转换为匹配条件
4. **匹配逻辑**：支持 AND/OR 嵌套组合
5. **操作符**：支持多种字符串、数值、存在性操作符
6. **声明式设计**：只需要定义"识别什么"，系统自动决定"怎么识别"

下一步：[简单规则编写指南](./02_简单规则编写.md)
