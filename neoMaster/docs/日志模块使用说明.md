# NeoScan 日志模块使用说明

## 1. 概述

NeoScan 日志模块基于 **logrus** 构建，提供了结构化、可配置的日志记录功能。支持多种日志类型、输出格式和轮转策略，满足开发、测试和生产环境的不同需求。

## 2. 配置文件

### 2.1 配置文件位置

- **开发环境**: `configs/config.yaml`
- **测试环境**: `configs/config.test.yaml`
- **生产环境**: `configs/config.prod.yaml`
- **环境变量**: `configs/.env`

### 2.2 日志配置参数

在配置文件中的 `log` 节点下配置日志参数：

```yaml
# 日志配置
log:
  level: "info"                    # 日志级别
  format: "json"                   # 输出格式
  output: "stdout"                 # 输出目标
  file_path: "logs/app.log"        # 文件路径（当output为file时）
  max_size: 100                    # 单个文件最大大小（MB）
  max_backups: 5                   # 保留的备份文件数量
  max_age: 30                      # 日志文件保留天数
  compress: true                   # 是否压缩历史日志
  caller: true                     # 是否显示调用者信息
  stack_trace: true                # 是否显示堆栈跟踪
```

#### 配置参数说明

| 参数 | 类型 | 可选值 | 默认值 | 说明 |
|------|------|--------|--------|---------|
| `level` | string | debug, info, warn, error, fatal, panic | info | 日志级别，只记录该级别及以上的日志 |
| `format` | string | json, text | json | 日志输出格式 |
| `output` | string | stdout, stderr, file | stdout | 日志输出目标 |
| `file_path` | string | 任意有效路径 | logs/app.log | 日志文件路径（仅当output为file时有效） |
| `max_size` | int | > 0 | 100 | 单个日志文件最大大小（MB） |
| `max_backups` | int | >= 0 | 5 | 保留的历史日志文件数量 |
| `max_age` | int | >= 0 | 30 | 日志文件保留天数 |
| `compress` | bool | true, false | true | 是否压缩历史日志文件 |
| `caller` | bool | true, false | true | 是否在日志中显示调用者信息 |

### 2.3 不同环境的推荐配置

#### 开发环境
```yaml
log:
  level: "debug"
  format: "text"      # 文本格式更易读
  output: "stdout"
  caller: true
```

#### 测试环境
```yaml
log:
  level: "info"
  format: "json"
  output: "file"
  file_path: "logs/test.log"
  max_size: 50
  max_backups: 3
  compress: true
```

#### 生产环境
```yaml
log:
  level: "warn"       # 生产环境建议warn级别以上
  format: "json"      # JSON格式便于日志分析
  output: "file"
  file_path: "logs/prod.log"
  max_size: 200
  max_backups: 10
  max_age: 90
  compress: true
  caller: false       # 生产环境关闭调用者信息提升性能
```

## 3. 日志输出位置

### 3.1 控制台输出

当 `output` 设置为 `stdout` 或 `stderr` 时，日志直接输出到控制台。

### 3.2 文件输出

当 `output` 设置为 `file` 时，**所有不同类型的日志都会输出到同一个文件中**：

- **主日志文件**: `logs/app.log`（可通过 `file_path` 配置）
- **轮转文件**: `logs/app.log.1`, `logs/app.log.2` 等
- **压缩文件**: `logs/app.log.1.gz`, `logs/app.log.2.gz` 等（当 `compress: true` 时）

#### 统一文件输出说明

系统使用全局单例 `LoggerInstance` 管理所有日志输出，无论是业务日志、错误日志、系统日志还是审计日志，都会写入到同一个配置的日志文件中。这种设计有以下优势：

- **简化管理**: 只需要管理一个日志文件和轮转策略
- **统一配置**: 所有日志类型共享相同的格式、级别和轮转设置
- **便于分析**: 可以在单个文件中查看完整的应用运行状态
- **降低复杂度**: 避免多文件管理的复杂性和磁盘碎片

#### 日志类型区分

虽然所有日志输出到同一个文件，但每条日志都包含 `"type"` 字段来区分日志类型：

```json
{
  "type": "business",    // 日志类型标识
  "level": "info",
  "message": "Business operation: login",
  "operation": "login",
  "user_id": 1001,
  // ... 其他字段
}
```

**支持的日志类型标识**：
- `"access"` - HTTP访问日志
- `"business"` - 业务操作日志  
- `"error"` - 错误日志
- `"system"` - 系统事件日志
- `"audit"` - 审计日志
- `"debug"` - 调试日志

#### 日志过滤和查询

可以通过 `type` 字段过滤特定类型的日志：

```bash
# 查看所有业务操作日志
grep '"type":"business"' logs/app.log

# 查看所有错误日志
grep '"type":"error"' logs/app.log

# 查看特定用户的操作日志
grep '"user_id":1001' logs/app.log | grep '"type":"business"'

# 使用jq工具进行复杂查询（JSON格式）
cat logs/app.log | jq 'select(.type == "business" and .result == "failed")'
```

### 3.3 日志轮转规则

- **按大小轮转**: 当日志文件达到 `max_size` 指定的大小时自动轮转
- **按时间清理**: 超过 `max_age` 天数的日志文件自动删除
- **数量限制**: 最多保留 `max_backups` 个历史文件
- **压缩存储**: 历史文件可选择 gzip 压缩以节省空间

## 4. 使用方法

### 4.1 初始化日志管理器

在应用启动时初始化日志管理器：

```go
package main

import (
    "neomaster/internal/config"
    "neomaster/internal/pkg/logger"
)

func main() {
    // 加载配置
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }

    // 初始化日志管理器
    loggerManager, err := logger.InitLogger(cfg.Log)
    if err != nil {
        log.Fatalf("Failed to initialize logger: %v", err)
    }

    // 日志管理器初始化完成，可以开始使用
    logger.Info("Application started")
}
```

### 4.2 业务操作日志

记录用户的业务操作，如登录、注册、权限变更等：

```go
// 记录用户登录成功
logger.LogBusinessOperation(
    "login",                    // 操作类型
    1001,                       // 用户ID
    "testuser",                 // 用户名
    "192.168.1.100",            // 客户端IP
    "req-12345",                // 请求ID
    "success",                  // 操作结果（success/failed）
    "用户登录成功",                // 详细消息
    map[string]interface{}{     // 额外字段
        "login_method": "password",
        "device": "web",
        "browser": "Chrome",
    },
)

// 记录用户注册
logger.LogBusinessOperation(
    "register",
    1002,
    "newuser",
    "192.168.1.101",
    "req-12346",
    "success",
    "用户注册成功",
    map[string]interface{}{
        "email": "newuser@example.com",
        "registration_method": "email",
    },
)

// 记录操作失败
logger.LogBusinessOperation(
    "login",
    0, // 未知用户ID
    "unknown",
    "192.168.1.102",
    "req-12347",
    "failed", // 失败状态
    "用户名或密码错误",
    map[string]interface{}{
        "attempt_count": 3,
        "reason": "invalid_credentials",
    },
)
```

### 4.3 错误日志

记录系统错误、异常和业务错误：

```go
// 记录数据库连接错误
logger.LogError(
    fmt.Errorf("数据库连接失败: connection timeout"),
    "req-12347",        // 请求ID
    1001,               // 用户ID
    "192.168.1.100",    // 客户端IP
    "/api/users",       // 请求路径
    "GET",              // HTTP方法
    map[string]interface{}{
        "database": "mysql",
        "timeout": "30s",
        "retry_count": 3,
    },
)

// 记录业务逻辑错误
logger.LogError(
    fmt.Errorf("用户权限不足"),
    "req-12348",
    1001,
    "192.168.1.100",
    "/api/admin/users",
    "DELETE",
    map[string]interface{}{
        "required_role": "admin",
        "user_role": "user",
    },
)
```

### 4.4 系统事件日志

记录系统启动、关闭、组件状态变化等系统级事件：

```go
import "github.com/sirupsen/logrus"

// 记录系统启动事件
logger.LogSystemEvent(
    "database",              // 组件名称
    "startup",               // 事件类型
    "数据库连接池初始化完成",      // 事件消息
    logrus.InfoLevel,        // 日志级别
    map[string]interface{}{
        "max_connections": 100,
        "idle_connections": 10,
        "driver": "mysql",
    },
)

// 记录系统警告事件
logger.LogSystemEvent(
    "memory",
    "high_usage",
    "内存使用率过高",
    logrus.WarnLevel,
    map[string]interface{}{
        "usage_percent": 85.5,
        "threshold": 80.0,
    },
)

// 记录系统错误事件
logger.LogSystemEvent(
    "redis",
    "connection_failed",
    "Redis连接失败",
    logrus.ErrorLevel,
    map[string]interface{}{
        "host": "localhost:6379",
        "error": "connection refused",
    },
)
```

### 4.5 审计日志

记录安全相关的操作，满足审计和合规要求：

```go
// 记录管理员删除用户操作
logger.LogAuditOperation(
    1001,                    // 操作用户ID
    "admin",                 // 操作用户名
    "delete_user",           // 操作类型
    "user:1002",             // 操作资源
    "success",               // 操作结果
    "192.168.1.100",         // 客户端IP
    "Mozilla/5.0 Chrome/91", // User-Agent
    "req-12348",             // 请求ID
    map[string]interface{}{
        "reason": "违规用户",
        "admin_level": "super",
    },
)

// 记录权限变更操作
logger.LogAuditOperation(
    1001,
    "admin",
    "change_user_role",
    "user:1003",
    "success",
    "192.168.1.100",
    "Mozilla/5.0 Chrome/91",
    "req-12349",
    map[string]interface{}{
        "old_role": "user",
        "new_role": "moderator",
        "approval_id": "APP-001",
    },
)
```

### 4.6 HTTP请求日志

记录HTTP请求的访问日志：

```go
// 在标准HTTP处理器中记录请求
func handleRequest(w http.ResponseWriter, r *http.Request) {
    start := time.Now()
    
    // 处理请求逻辑...
    
    // 记录请求日志
    logger.LogHTTPRequest(
        r,                           // HTTP请求对象
        http.StatusOK,              // 响应状态码
        time.Since(start),          // 响应时间
        "req-12350",                // 请求ID
        1001,                       // 用户ID（如果已认证）
    )
}
```

### 4.7 简单日志记录

对于简单的日志记录，可以直接使用便捷方法：

```go
// 调试日志
logger.Debug("调试信息")
logger.Debugf("用户ID: %d, 操作: %s", userID, operation)

// 信息日志
logger.Info("应用启动成功")
logger.Infof("处理请求: %s %s", method, path)

// 警告日志
logger.Warn("配置项缺失，使用默认值")
logger.Warnf("连接池使用率: %.2f%%", usage)

// 错误日志
logger.Error("数据库连接失败")
logger.Errorf("解析JSON失败: %v", err)

// 致命错误（会导致程序退出）
logger.Fatal("无法启动服务器")
logger.Fatalf("配置文件错误: %v", err)
```

## 5. 日志输出格式

### 5.1 JSON格式（生产环境推荐）

```json
{
  "level": "info",
  "message": "Business operation: login",
  "timestamp": "2025-09-03T14:48:22+08:00",
  "type": "business",
  "operation": "login",
  "user_id": 1001,
  "username": "testuser",
  "client_ip": "192.168.1.100",
  "result": "success",
  "request_id": "req-12345",
  "login_method": "password",
  "device": "web",
  "file": "internal/pkg/logger/formatter.go:181",
  "function": "neomaster/internal/pkg/logger.LogBusinessOperation"
}
```

### 5.2 文本格式（开发环境推荐）

```
INFO[2025-09-03T14:51:15+08:00] Business operation: login
client_ip=192.168.1.100 device=web login_method=password 
message="用户登录成功" operation=login request_id=req-12345 
result=success type=business user_id=1001 username=testuser
```

## 6. 日志类型说明

| 日志类型 | 标识符 | 用途 | 示例场景 |
|----------|--------|------|----------|
| **AccessLog** | `access` | HTTP请求访问日志 | API调用、页面访问 |
| **BusinessLog** | `business` | 业务操作日志 | 用户登录、注册、下单 |
| **ErrorLog** | `error` | 错误日志 | 系统异常、业务错误 |
| **SystemLog** | `system` | 系统日志 | 服务启动、组件状态 |
| **AuditLog** | `audit` | 审计日志 | 权限变更、敏感操作 |
| **DebugLog** | `debug` | 调试日志 | 开发调试信息 |

## 7. 中间件集成

日志模块已集成到Gin中间件中，自动记录HTTP请求：

```go
// 在路由中使用日志中间件
func setupRoutes(r *gin.Engine, middleware *MiddlewareManager) {
    // 应用日志中间件
    r.Use(middleware.GinLoggingMiddleware())
    
    // 定义路由...
}
```

中间件会自动记录：
- 请求方法和路径
- 响应状态码和时间
- 客户端IP和User-Agent
- 请求和响应大小
- 用户信息（如果已认证）

## 8. 最佳实践

### 8.1 日志级别使用建议

- **Debug**: 详细的调试信息，仅在开发环境使用
- **Info**: 一般信息，记录正常的业务流程
- **Warn**: 警告信息，需要关注但不影响正常运行
- **Error**: 错误信息，需要立即处理的问题
- **Fatal**: 致命错误，会导致程序退出

### 8.2 结构化日志字段

建议在额外字段中包含以下信息：

```go
extraFields := map[string]interface{}{
    "module": "user_service",      // 模块名称
    "function": "CreateUser",      // 函数名称
    "duration": "150ms",           // 执行时间
    "database": "mysql",           // 相关组件
    "trace_id": "trace-12345",     // 链路追踪ID
}
```

### 8.3 敏感信息处理

**注意**: 不要在日志中记录敏感信息，如：
- 密码
- 身份证号
- 银行卡号
- API密钥
- 个人隐私信息

```go
// ❌ 错误示例
logger.LogBusinessOperation("login", userID, username, clientIP, requestID, "success", 
    "用户登录", map[string]interface{}{
        "password": "123456",  // 不要记录密码
    })

// ✅ 正确示例
logger.LogBusinessOperation("login", userID, username, clientIP, requestID, "success", 
    "用户登录", map[string]interface{}{
        "login_method": "password",
        "device": "web",
    })
```

### 8.4 性能考虑

- 在高并发场景下，建议将日志级别设置为 `warn` 或 `error`
- 关闭调用者信息（`caller: false`）可以提升性能
- 使用异步日志写入，避免阻塞业务逻辑
- 定期清理历史日志文件，避免磁盘空间不足

## 9. 故障排查

### 9.1 常见问题

#### 日志文件无法创建
```
failed to create log directory: permission denied
```
**解决方案**: 检查日志目录权限，确保应用有写入权限。

#### 日志轮转不工作
```
log file size exceeds max_size but no rotation occurred
```
**解决方案**: 检查 `max_size`、`max_backups` 配置是否正确。

#### 日志格式错误
```
unsupported log format: xml
```
**解决方案**: 确保 `format` 配置为 `json` 或 `text`。

### 9.2 调试日志配置

可以通过以下方式验证日志配置：

```go
// 获取当前日志配置
if logger.LoggerInstance != nil {
    config := logger.LoggerInstance.GetConfig()
    fmt.Printf("当前日志级别: %s\n", config.Level)
    fmt.Printf("当前日志格式: %s\n", config.Format)
    fmt.Printf("当前输出目标: %s\n", config.Output)
}
```

## 10. 示例代码

完整的使用示例请参考项目中的测试文件：
- `test_logger.go` - JSON格式输出示例
- `test_logger_text.go` - 文本格式输出示例

运行示例：
```bash
# JSON格式示例
go run test_logger.go

# 文本格式示例
go run test_logger_text.go
```

## 11. 相关文件

- **日志管理器**: `internal/pkg/logger/logger.go`
- **日志格式化器**: `internal/pkg/logger/formatter.go`
- **配置文件**: `configs/config.yaml`
- **中间件**: `internal/app/master/middleware.go`
- **测试示例**: `test_logger.go`, `test_logger_text.go`

---

**更新时间**: 2025-09-03  
**版本**: v1.0  
**维护者**: NeoScan开发团队