---20250915
1.用户模型的时间字段使用的time.Time类型,没有统一时间格式.
2.用户注册的时候没有默认给用户分配角色，增加分配默认角色为普通用户.
3.管理员-用户管理-更新用户信息 接口有问题，是会修改status状态
4.管理员-用户管理，激活和禁用接口有问题，报错。
---20250916
1.修复接口管理员-用户管理-更新用户信息问题，但移除该接口修改角色的功能
2.解决获取角色详情的接口没有获取到角色权限信息问题
3.更新角色接口连带着角色权限的时候会触发死锁,validateRoleForUpdate改用roleRepo.GetRoleWithPermissions获取角色及权限信息。问题未解决
---20250918
1.更新角色信息带权限的时候，有时成功有时失败，好神奇，已修复（原因：错把角色id当成了权限id使用并查询了）
---20250919
1.删除角色和权限的时候遇到了mysql锁表问题，需要将所有操作都放到同一个事务中。
2.会话登录的时候，没有会话单独的会话ID，导致查询用所所有会话时有bug
3.解决了用户会话删除但原本token还生效的bug（JWT验证令牌增加了对redis里面的accessToken的存在和黑名单的判断）
4.修复了用户会话删除但用户登录的bug
5.优化了中间件jwt的校验
6.还有部分API返回格式不统一，时间格式不统一，clientIP没有统一格式化，userAgent没有统一格式化等

# 格式化客户端IP的方法，目前只有注册时有，其他地方没有，需要补充
    clientIPRaw := c.GetHeader("X-Forwarded-For")
	if clientIPRaw == "" {
		clientIPRaw = c.GetHeader("X-Real-IP")
	}
	if clientIPRaw == "" {
		clientIPRaw = c.ClientIP()
	}
	clientIP := utils.NormalizeIP(clientIPRaw)
	userAgent := c.GetHeader("User-Agent")
# 这里带上登录IP
    user := &model.User{
		Username:    req.Username,
		Email:       req.Email,
		Nickname:    req.Nickname,
		Password:    hashedPassword, // 使用哈希后的密码
		Phone:       req.Phone,
		Status:      model.UserStatusEnabled,
		PasswordV:   1,        // 设置密码版本
		LastLoginIP: clientIP, // 注册时记录注册IP到 LastLoginIP 字段
	}

---20250922 
1. 删除token黑名单机制缓存，使用密码版本统一让所有token失效
---20250923
1. 在ValidateRefreshToken函数中如果添加密码版本验证，会导致系统报错如下（所以暂时取消密码版本验证）：(已修复)
	runtime: goroutine stack exceeds 1000000000-byte limit runtime: sp=0xc02f5194b0 stack=[0xc02f518000, 0xc04f518000]
	- 数据结构：JWTService依赖SessionService，SessionService又依赖JWTService，形成循环
	- 报错原因：循环依赖会导致无限递归初始化，最终栈溢出
2. 用户信息更新接口存在响应错误，响应没有根据具体错误类型返回，只返回了更新失败，涉及接口管理员使用用户更新接口和用户使用的更新接口，已修复
---20250924
1.handler使用Gin上下文，service层后使用标准上下文，一方面是和web框架解耦设计，另一方面是避免了Gin上下文和标准上下文之间的依赖关系
	- 这样做需要在中间件中把必要的信息从Gin上下文中取出来，并保存到标准上下文中
	- 示例代码：
		// 定义一个常量作为上下文键,避免使用空的匿名结构体
		var clientIPKey = clientIPKeyType{}
		ctx = context.WithValue(ctx, clientIPKey, clientIP)
		// c.Request.Context()返回是标准的context.Context上下文，不包含gin的上下文
		// 可以使用WithValue方法将自定义的上下文值存储到标准上下文中
		// 这样后续使用标准上下文为参数的函数就可以安全获取自定义的上下文值
		// 获取方式：clientIP, _ := ctx.Value("client_ip").(string)
		c.Request = c.Request.WithContext(ctx)
		// 本项目只有handler中使用了Gin上下文，剩下的逻辑都在service中使用的标准上下文
		// 所以这里需要将Gin上下文的client_ip也存储到标准上下文

