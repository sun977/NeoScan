# 调度架构演进：从线性流转到 DAG (有向无环图)

## 0. 核心哲学
> **"Bad programmers worry about the code. Good programmers worry about data structures."**  
> — *Linus Torvalds*

NeoScan 的调度系统正处于从 "玩具级" 向 "生产级" 进化的关键节点。当前仅仅依靠 `StageOrder` (int) 来控制流程是不可接受的简化，它将导致严重的性能瓶颈和逻辑限制。

本文档详细阐述了为什么**必须**引入 DAG (有向无环图) 结构，以及它如何解决现实世界中的扫描难题。

---

## 1. 现状：线性流转 (The Linear Trap)

### 定义
线性流转是指工作流中的阶段（Stage）严格按照顺序执行：`Stage 1 -> Stage 2 -> Stage 3`。前一阶段必须**完全结束**，下一阶段才能开始。

### 致命缺陷

#### 1.1 "The Straggler Problem" (长尾阻塞) —— 性能杀手
这是最致命的问题。
*   **场景**：扫描 10,000 个 IP。
*   **现象**：前 9,990 个 IP 在 5 分钟内完成端口扫描，但最后 10 个 IP 因为网络问题或防火墙陷阱 (Tarpit) 卡住了 1 小时。
*   **后果**：整个工作流停滞。下一阶段（如 Web 探测）无法启动，9,990 个已完成目标的扫描结果在数据库里"发霉"。系统吞吐量被最慢的那个任务拖死。

#### 1.2 资源利用率的 "锯齿效应"
*   **场景**：Stage 1 是网络密集型（端口扫描），Stage 2 是 CPU 密集型（指纹计算）。
*   **后果**：
    *   **T1 时段**：网络带宽打满，CPU 闲置。
    *   **T2 时段**：CPU 跑满，网络闲置。
*   **结论**：硬件资源永远只有 50% 的利用率。

#### 1.3 逻辑僵化
*   **限制**：无法表达 "如果 A 则 B，否则 C" 的逻辑。
*   **后果**：对非 Web 端口也尝试加载 Web 插件，造成纯粹的资源浪费。

---

## 2. 目标：DAG (Directed Acyclic Graph)

### 定义
DAG 允许任务之间存在**有向依赖**关系，但不存在循环。它不仅仅是顺序的连接，更支持**分叉 (Fork)**、**汇聚 (Join)** 和 **并行 (Parallel)**。

### 核心优势

#### 2.1 流式处理 (Streaming / Pipelining)
**"依赖" 不等于 "阻塞"。**
*   **机制**：Stage 2 订阅 Stage 1 的**输出流**，而不是等待 Stage 1 的**结束信号**。
*   **效果**：只要 Stage 1 产出第一个结果（如发现一个开放端口），Stage 2 立即对该结果启动扫描。
*   **解决**：彻底消灭 "长尾阻塞"。快的目标先跑完整个流程，慢的目标慢慢跑，互不干扰。

#### 2.2 扇出 (Fan-out) 与 并行
*   **机制**：一个 Stage 的结果可以同时触发多个下游 Stage。
*   **效果**：端口扫描发现 Web 服务后，可以**同时**触发 "指纹识别" 和 "目录爆破"。总耗时取决于最慢的那个路径，而不是两者之和。

---

## 3. 场景推演对比

### 场景 A：大规模资产扫描 (10k IPs)

| 维度 | 线性流转 (Linear) | DAG 流水线 (Pipeline) |
| :--- | :--- | :--- |
| **执行逻辑** | 批处理：等 10k 全部扫完端口，再一起扫 Web。 | 流式：扫出一个端口，就扫一个 Web。 |
| **异常处理** | 1 个 IP 超时 = 全员等待。 | 1 个 IP 超时 = 仅该 IP 的后续任务延迟。 |
| **总耗时** | **5小时** (受限于最慢节点) | **1小时** (平均处理时间) |

### 场景 B：混合负载 (CPU + Network)

| 维度 | 线性流转 (Linear) | DAG 流水线 (Pipeline) |
| :--- | :--- | :--- |
| **资源图表** | 📉📈📉 (锯齿状) | 📊 (平稳高水位) |
| **利用率** | 互斥：要么用网，要么用 CPU。 | 互补：同时有任务在发包，有任务在计算。 |

### 场景 C：战术分支 (Smart Scanning)

*   **需求**：
    *   如果是 80/443 -> 跑 Web 插件
    *   如果是 22 -> 跑 SSH 爆破
    *   如果是 445 -> 跑 SMB 探测
*   **线性方案**：做不到。只能把所有插件都跑一遍，大部分会报错退出。
*   **DAG 方案**：
    ```mermaid
    graph LR
        PortScan -->|Port=80| WebScan
        PortScan -->|Port=22| SSHBrute
        PortScan -->|Port=445| SMBProbe
    ```
    **只做有意义的事。**

---

## 4. 结论与重构方向

**线性流转是原型的产物，DAG 是生产系统的基石。**

为了构建一个高性能、可扩展且智能的扫描引擎，我们必须：

1.  **数据结构重构**：废弃 `StageOrder` (int)，引入 `Dependencies` (List of StageIDs)。
2.  **调度引擎重写**：从 "计数器模式" 升级为 "事件驱动的状态机模式"。
3.  **状态管理升级**：支持任务粒度的流转，而不仅仅是项目粒度的状态。
